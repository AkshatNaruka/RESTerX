package pkg

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"
)

// MockServer provides mock API functionality
type MockServer struct {
	endpoints map[string]*MockEndpoint
	port      string
}

// MockEndpoint represents a mocked API endpoint
type MockEndpoint struct {
	ID          string            `json:"id"`
	Path        string            `json:"path"`
	Method      string            `json:"method"`
	StatusCode  int               `json:"statusCode"`
	Headers     map[string]string `json:"headers"`
	Body        string            `json:"body"`
	Delay       int               `json:"delay"` // milliseconds
	Description string            `json:"description"`
	CreatedAt   time.Time         `json:"createdAt"`
}

// MockResponse represents a mock response configuration
type MockResponse struct {
	StatusCode int               `json:"statusCode"`
	Headers    map[string]string `json:"headers"`
	Body       string            `json:"body"`
	Delay      int               `json:"delay"`
}

// NewMockServer creates a new mock server
func NewMockServer(port string) *MockServer {
	return &MockServer{
		endpoints: make(map[string]*MockEndpoint),
		port:      port,
	}
}

// AddEndpoint adds a new mock endpoint
func (ms *MockServer) AddEndpoint(endpoint *MockEndpoint) {
	key := fmt.Sprintf("%s:%s", endpoint.Method, endpoint.Path)
	endpoint.ID = generateMockID()
	endpoint.CreatedAt = time.Now()
	ms.endpoints[key] = endpoint
}

// RemoveEndpoint removes a mock endpoint
func (ms *MockServer) RemoveEndpoint(method, path string) {
	key := fmt.Sprintf("%s:%s", method, path)
	delete(ms.endpoints, key)
}

// GetEndpoints returns all mock endpoints
func (ms *MockServer) GetEndpoints() map[string]*MockEndpoint {
	return ms.endpoints
}

// HandleMockRequest handles incoming mock requests
func (ms *MockServer) HandleMockRequest(w http.ResponseWriter, r *http.Request) {
	key := fmt.Sprintf("%s:%s", r.Method, r.URL.Path)
	
	endpoint, exists := ms.endpoints[key]
	if !exists {
		// Try wildcard matching
		endpoint = ms.findWildcardMatch(r.Method, r.URL.Path)
		if endpoint == nil {
			ms.sendNotFoundResponse(w)
			return
		}
	}

	// Add delay if specified
	if endpoint.Delay > 0 {
		time.Sleep(time.Duration(endpoint.Delay) * time.Millisecond)
	}

	// Set response headers
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Mock-Server", "RESTerX")
	
	for key, value := range endpoint.Headers {
		w.Header().Set(key, value)
	}

	// Set status code
	w.WriteHeader(endpoint.StatusCode)

	// Send response body
	w.Write([]byte(endpoint.Body))
}

// findWildcardMatch finds matching endpoints with wildcard support
func (ms *MockServer) findWildcardMatch(method, path string) *MockEndpoint {
	for key, endpoint := range ms.endpoints {
		if strings.HasPrefix(key, method+":") {
			endpointPath := strings.TrimPrefix(key, method+":")
			if ms.pathMatches(endpointPath, path) {
				return endpoint
			}
		}
	}
	return nil
}

// pathMatches checks if a path matches with wildcard support
func (ms *MockServer) pathMatches(pattern, path string) bool {
	// Simple wildcard matching for paths like /api/users/* or /api/users/{id}
	if strings.Contains(pattern, "*") {
		prefix := strings.Split(pattern, "*")[0]
		return strings.HasPrefix(path, prefix)
	}
	
	if strings.Contains(pattern, "{") && strings.Contains(pattern, "}") {
		// Simple parameter matching
		patternParts := strings.Split(pattern, "/")
		pathParts := strings.Split(path, "/")
		
		if len(patternParts) != len(pathParts) {
			return false
		}
		
		for i, part := range patternParts {
			if strings.HasPrefix(part, "{") && strings.HasSuffix(part, "}") {
				continue // This is a parameter, skip
			}
			if part != pathParts[i] {
				return false
			}
		}
		return true
	}
	
	return pattern == path
}

// sendNotFoundResponse sends a 404 response
func (ms *MockServer) sendNotFoundResponse(w http.ResponseWriter) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusNotFound)
	response := map[string]string{
		"error":   "Endpoint not found",
		"message": "This mock endpoint has not been configured",
		"server":  "RESTerX Mock Server",
	}
	json.NewEncoder(w).Encode(response)
}

// GenerateDocumentation generates API documentation from mock endpoints
func (ms *MockServer) GenerateDocumentation() string {
	var doc strings.Builder
	
	doc.WriteString("# API Documentation\n\n")
	doc.WriteString("Generated by RESTerX Mock Server\n\n")
	doc.WriteString(fmt.Sprintf("**Base URL**: http://localhost:%s\n\n", ms.port))
	
	if len(ms.endpoints) == 0 {
		doc.WriteString("No endpoints configured.\n")
		return doc.String()
	}
	
	doc.WriteString("## Endpoints\n\n")
	
	for _, endpoint := range ms.endpoints {
		doc.WriteString(fmt.Sprintf("### %s %s\n\n", endpoint.Method, endpoint.Path))
		
		if endpoint.Description != "" {
			doc.WriteString(fmt.Sprintf("%s\n\n", endpoint.Description))
		}
		
		doc.WriteString("**Response:**\n")
		doc.WriteString(fmt.Sprintf("- Status Code: %d\n", endpoint.StatusCode))
		
		if len(endpoint.Headers) > 0 {
			doc.WriteString("- Headers:\n")
			for k, v := range endpoint.Headers {
				doc.WriteString(fmt.Sprintf("  - %s: %s\n", k, v))
			}
		}
		
		if endpoint.Body != "" {
			doc.WriteString("- Body:\n")
			doc.WriteString("```json\n")
			doc.WriteString(endpoint.Body)
			doc.WriteString("\n```\n\n")
		}
		
		if endpoint.Delay > 0 {
			doc.WriteString(fmt.Sprintf("- Response Delay: %dms\n", endpoint.Delay))
		}
		
		doc.WriteString("---\n\n")
	}
	
	return doc.String()
}

// ExportOpenAPI exports endpoints as OpenAPI specification
func (ms *MockServer) ExportOpenAPI() map[string]interface{} {
	openapi := map[string]interface{}{
		"openapi": "3.0.0",
		"info": map[string]interface{}{
			"title":       "RESTerX Mock API",
			"description": "Mock API generated by RESTerX",
			"version":     "1.0.0",
		},
		"servers": []map[string]interface{}{
			{
				"url":         fmt.Sprintf("http://localhost:%s", ms.port),
				"description": "Mock Server",
			},
		},
		"paths": make(map[string]interface{}),
	}
	
	paths := openapi["paths"].(map[string]interface{})
	
	for _, endpoint := range ms.endpoints {
		if paths[endpoint.Path] == nil {
			paths[endpoint.Path] = make(map[string]interface{})
		}
		
		pathObj := paths[endpoint.Path].(map[string]interface{})
		
		pathObj[strings.ToLower(endpoint.Method)] = map[string]interface{}{
			"summary":     endpoint.Description,
			"description": fmt.Sprintf("Mock endpoint for %s %s", endpoint.Method, endpoint.Path),
			"responses": map[string]interface{}{
				fmt.Sprintf("%d", endpoint.StatusCode): map[string]interface{}{
					"description": "Mock response",
					"content": map[string]interface{}{
						"application/json": map[string]interface{}{
							"example": endpoint.Body,
						},
					},
				},
			},
		}
	}
	
	return openapi
}

// generateMockID generates a unique ID for mock endpoints
func generateMockID() string {
	return fmt.Sprintf("mock_%d", time.Now().UnixNano())
}